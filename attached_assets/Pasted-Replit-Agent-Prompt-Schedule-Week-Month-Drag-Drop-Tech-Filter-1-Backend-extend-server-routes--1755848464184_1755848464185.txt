Replit Agent Prompt — Schedule: Week/Month, Drag-Drop, Tech Filter
1) Backend: extend server/routes/jobs.ts

Add these routes (below your existing ones):

// --- TECH FILTER SOURCE ---
// Return technicians in this org (id + name). Adjust query if your schema differs.
jobs.get("/technicians", requireAuth, requireOrg, async (req, res) => {
  const orgId = (req as any).orgId;
  const r: any = await db.execute(sql`
    select u.id, u.name, u.email
    from users u
    where u.org_id = ${orgId}::uuid
    order by u.name asc
  `);
  res.json(r.rows);
});

// --- RANGE with optional techId filter ---
jobs.get("/range", requireAuth, requireOrg, async (req, res) => {
  const orgId = (req as any).orgId;
  const { start, end, techId } = req.query as { start?: string; end?: string; techId?: string };

  if (!start || !end) return res.status(400).json({ error: "start and end are required (ISO strings)" });

  // If techId provided, join job_assignments to filter jobs for that tech
  const r: any = await db.execute(sql`
    select j.id, j.title, j.status, j.scheduled_at,
           j.customer_id, coalesce(c.name,'—') as customer_name
    from jobs j
    left join customers c on c.id = j.customer_id
    ${techId ? sql`
      join job_assignments ja on ja.job_id = j.id and ja.user_id = ${techId}::uuid
    ` : sql``}
    where j.org_id=${orgId}::uuid
      and j.scheduled_at is not null
      and j.scheduled_at >= ${start}::timestamptz
      and j.scheduled_at <  ${end}::timestamptz
    order by j.scheduled_at asc
  `);
  res.json(r.rows);
});

// --- DRAG-TO-RESCHEDULE (just update scheduled_at) ---
jobs.patch("/:jobId/schedule", requireAuth, requireOrg, async (req, res) => {
  const { jobId } = req.params;
  const orgId = (req as any).orgId;
  const { scheduledAt } = req.body || {};
  if (!jobId || !/^[0-9a-f-]{36}$/i.test(jobId)) return res.status(400).json({ error: "invalid jobId" });
  if (!scheduledAt) return res.status(400).json({ error: "scheduledAt required (ISO)" });

  await db.execute(sql`
    update jobs set scheduled_at = ${scheduledAt}::timestamptz
    where id=${jobId}::uuid and org_id=${orgId}::uuid
  `);

  res.json({ ok: true });
});


No other server changes needed; existing /api/jobs routes stay as-is.

2) Client API — client/src/lib/api.ts

Add helpers:

export const jobsApi = {
  // ...existing
  byRange: (startISO: string, endISO: string, techId?: string) =>
    api(`/api/jobs/range?start=${encodeURIComponent(startISO)}&end=${encodeURIComponent(endISO)}${techId ? `&techId=${encodeURIComponent(techId)}` : ""}`),
  technicians: () => api("/api/jobs/technicians"),
  reschedule: (id: string, scheduledAtISO: string) =>
    api(`/api/jobs/${id}/schedule`, { method: "PATCH", body: JSON.stringify({ scheduledAt: scheduledAtISO }) }),
};

3) Schedule page — client/src/pages/schedule.tsx

Replace your existing file with this upgraded version:

import { useMemo, useState, useEffect } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { addMonths, subMonths, startOfMonth, endOfMonth, startOfWeek, endOfWeek, addDays, isSameMonth, isToday, format, set } from "date-fns";
import { jobsApi } from "@/lib/api";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useLocation, Link } from "wouter";

type Job = {
  id: string;
  title: string;
  status: string;
  scheduled_at: string;
  customer_name?: string;
};

type ViewMode = "month" | "week";

// helpers
function statusTone(s: string) {
  if (!s) return "bg-gray-200 text-gray-700";
  if (s === "new") return "bg-blue-100 text-blue-800";
  if (s === "scheduled") return "bg-indigo-100 text-indigo-800";
  if (s === "in_progress") return "bg-amber-100 text-amber-800";
  if (s === "done" || s === "completed") return "bg-emerald-100 text-emerald-800";
  if (s === "cancelled") return "bg-rose-100 text-rose-800";
  return "bg-gray-200 text-gray-700";
}
function clampIsoDayWithTime(newDay: Date, timeFrom: Date) {
  // keep original hours:minutes of the job when moving between days
  return set(newDay, { hours: timeFrom.getHours(), minutes: timeFrom.getMinutes(), seconds: 0, milliseconds: 0 }).toISOString();
}

export default function SchedulePage() {
  const [, navigate] = useLocation();
  const qc = useQueryClient();

  // view + cursor date
  const [view, setView] = useState<ViewMode>("month");
  const [cursor, setCursor] = useState<Date>(new Date());

  // tech filter (single-select for now; can upgrade to multi later)
  const [techId, setTechId] = useState<string>("");

  // compute range
  const monthStart = startOfMonth(cursor);
  const monthEnd   = endOfMonth(cursor);
  const gridStartM = startOfWeek(monthStart, { weekStartsOn: 1 });
  const gridEndM   = endOfWeek(monthEnd, { weekStartsOn: 1 });

  const weekStart  = startOfWeek(cursor, { weekStartsOn: 1 });
  const weekEnd    = endOfWeek(cursor,   { weekStartsOn: 1 });

  const startDate = view === "month" ? gridStartM : weekStart;
  const endDate   = view === "month" ? gridEndM   : weekEnd;

  const startISO = startDate.toISOString();
  const endISO   = endDate.toISOString();

  // fetch jobs in window (optionally filtered by tech)
  const { data: jobs = [], isLoading } = useQuery({
    queryKey: ["/api/jobs/range", startISO, endISO, techId || ""],
    queryFn: () => jobsApi.byRange(startISO, endISO, techId || undefined),
  });

  // fetch technicians for dropdown
  const { data: techs = [] } = useQuery({
    queryKey: ["/api/jobs/technicians"],
    queryFn: jobsApi.technicians,
  });

  // bucket jobs by yyyy-MM-dd
  const byDay = useMemo(() => {
    const map: Record<string, Job[]> = {};
    (jobs as Job[]).forEach((j) => {
      const key = format(new Date(j.scheduled_at), "yyyy-MM-dd");
      (map[key] ||= []).push(j);
    });
    return map;
  }, [jobs]);

  // build cells (either 6 weeks or 1 week)
  const cells: Date[] = [];
  for (let d = startDate; d <= endDate; d = addDays(d, 1)) cells.push(d);

  // day modal
  const [openDay, setOpenDay] = useState<Date | null>(null);
  const dayJobs: Job[] = useMemo(() => {
    if (!openDay) return [];
    const k = format(openDay, "yyyy-MM-dd");
    return byDay[k] || [];
  }, [openDay, byDay]);

  // drag & drop handlers (HTML5)
  function onDragStart(e: React.DragEvent, job: Job) {
    e.dataTransfer.setData("application/x-job-id", job.id);
    e.dataTransfer.setData("application/x-job-time", new Date(job.scheduled_at).toISOString());
    // allow move effect
    e.dataTransfer.effectAllowed = "move";
  }
  function onDragOver(e: React.DragEvent) {
    // allow drop
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  }
  async function onDrop(e: React.DragEvent, day: Date) {
    e.preventDefault();
    const id = e.dataTransfer.getData("application/x-job-id");
    const originalIso = e.dataTransfer.getData("application/x-job-time");
    if (!id || !originalIso) return;

    const newIso = clampIsoDayWithTime(day, new Date(originalIso));

    // optimistic: update cache for this range so UI moves instantly
    const key = ["/api/jobs/range", startISO, endISO, techId || ""];
    const prev = qc.getQueryData<Job[]>(key) || [];
    const next = (prev as Job[]).map(j => j.id === id ? { ...j, scheduled_at: newIso } : j);
    qc.setQueryData(key, next);

    try {
      await jobsApi.reschedule(id, newIso);
      // confirm with refetch
      qc.invalidateQueries({ queryKey: key });
    } catch (err) {
      // revert on error
      qc.setQueryData(key, prev);
      console.error("Reschedule failed", err);
      alert("Failed to reschedule job.");
    }
  }

  // UI
  const weekNames = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];

  return (
    <div className="p-6 space-y-4">
      {/* Header row */}
      <div className="flex items-center justify-between gap-3 flex-wrap">
        <div className="flex items-center gap-2">
          <h1 className="text-2xl font-bold">Schedule</h1>
          <div className="text-sm text-gray-500">
            {format(startDate, "d MMM")} – {format(endDate, "d MMM yyyy")}
          </div>
        </div>
        <div className="flex items-center gap-2">
          {/* View toggle */}
          <Select value={view} onValueChange={(v)=>setView(v as ViewMode)}>
            <SelectTrigger className="w-36"><SelectValue placeholder="View" /></SelectTrigger>
            <SelectContent>
              <SelectItem value="week">Week view</SelectItem>
              <SelectItem value="month">Month view</SelectItem>
            </SelectContent>
          </Select>

          {/* Technician filter */}
          <Select value={techId} onValueChange={setTechId}>
            <SelectTrigger className="w-48">
              <SelectValue placeholder="All technicians" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="">All technicians</SelectItem>
              {(techs as any[]).map(t => (
                <SelectItem key={t.id} value={t.id}>{t.name || t.email}</SelectItem>
              ))}
            </SelectContent>
          </Select>

          {/* Nav */}
          <Button variant="outline" onClick={() => setCursor(new Date())}>Today</Button>
          <Button variant="outline" onClick={() => setCursor(view === "month" ? subMonths(cursor,1) : addDays(cursor, -7))}>Prev</Button>
          <Button onClick={() => setCursor(view === "month" ? addMonths(cursor,1) : addDays(cursor, 7))}>Next</Button>
        </div>
      </div>

      {/* Grid */}
      <Card>
        <CardContent className="p-0">
          {/* Weekday header */}
          <div className="grid grid-cols-7 text-xs uppercase text-gray-500 border-b">
            {weekNames.map((w) => (<div key={w} className="px-3 py-2">{w}</div>))}
          </div>

          {/* Days */}
          <div className="grid grid-cols-7">
            {isLoading ? (
              <div className="col-span-7 p-8 text-center text-sm text-gray-500">Loading…</div>
            ) : (
              cells.map((d) => {
                const k = format(d, "yyyy-MM-dd");
                const list = byDay[k] || [];
                const faded = view === "month" && !isSameMonth(d, monthStart);
                const today = isToday(d);
                return (
                  <div
                    key={k}
                    onDragOver={onDragOver}
                    onDrop={(e)=>onDrop(e, d)}
                    className={[
                      view === "week" ? "h-64" : "h-36",
                      "p-2 border -m-[0.5px] text-left overflow-hidden",
                      "hover:bg-gray-50 transition",
                      faded ? "bg-gray-50/40 text-gray-400" : "bg-white",
                      today ? "ring-2 ring-primary/60 z-[1]" : ""
                    ].join(" ")}
                  >
                    <div className="flex items-center justify-between mb-1">
                      <button className="text-xs font-medium" onClick={()=>setOpenDay(d)}>
                        {format(d, "d")}
                      </button>
                      {!!list.length && (
                        <Badge className="text-[10px] py-0 px-1.5">{list.length}</Badge>
                      )}
                    </div>
                    <div className="space-y-1">
                      {list.slice(0, view === "week" ? 8 : 3).map((j) => (
                        <div
                          key={j.id}
                          draggable
                          onDragStart={(e)=>onDragStart(e, j)}
                          className={[
                            "text-[11px] px-1.5 py-0.5 rounded line-clamp-1 cursor-move",
                            statusTone(j.status)
                          ].join(" ")}
                          onClick={(e) => { e.stopPropagation(); navigate(`/jobs/${j.id}`); }}
                          title={`${j.title}${j.customer_name ? " — " + j.customer_name : ""}`}
                        >
                          {j.title}{j.customer_name ? ` — ${j.customer_name}` : ""}
                        </div>
                      ))}
                      {list.length > (view === "week" ? 8 : 3) && (
                        <button className="text-[10px] text-gray-500" onClick={()=>setOpenDay(d)}>
                          +{list.length - (view === "week" ? 8 : 3)} more…
                        </button>
                      )}
                    </div>
                  </div>
                );
              })
            )}
          </div>
        </CardContent>
      </Card>

      {/* Day modal */}
      <Dialog open={!!openDay} onOpenChange={(v) => setOpenDay(v ? openDay : null)}>
        <DialogContent className="max-w-lg">
          <DialogHeader>
            <DialogTitle>{openDay ? format(openDay, "EEEE, d MMM yyyy") : "Day"}</DialogTitle>
          </DialogHeader>
          {!openDay || (byDay[format(openDay, "yyyy-MM-dd")] || []).length === 0 ? (
            <div className="text-sm text-gray-500">No jobs scheduled.</div>
          ) : (
            <div className="space-y-2">
              {(byDay[format(openDay, "yyyy-MM-dd")] || []).map((j) => (
                <Link key={j.id} href={`/jobs/${j.id}`}>
                  <a className="block border rounded p-2 hover:bg-gray-50">
                    <div className="text-sm font-medium">{j.title}</div>
                    <div className="text-xs text-gray-600">
                      {j.customer_name || "—"} • {new Date(j.scheduled_at).toLocaleTimeString([], {hour: "2-digit", minute: "2-digit"})}
                    </div>
                  </a>
                </Link>
              ))}
            </div>
          )}
        </DialogContent>
      </Dialog>
    </div>
  );
}


Notes

Week view shows a single 7-day row; Month view uses the 6-row grid.

Drag & drop: grab a job pill and drop it on another day cell → it keeps the original time (HH:mm) and updates scheduled_at via PATCH /api/jobs/:id/schedule.

Technician filter: dropdown at top; when set, /range joins job_assignments to show only that tech’s jobs.

4) Test checklist

Toggle Week / Month and navigate with Prev/Next/Today.

Drag a job to another day → it moves immediately; persists after reload.

Choose a technician → only jobs assigned to them show.

Click a day → modal lists that day’s jobs; clicking one opens its card.