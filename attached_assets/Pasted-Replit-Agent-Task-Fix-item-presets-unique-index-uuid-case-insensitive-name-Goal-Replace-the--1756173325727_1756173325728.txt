Replit Agent Task — Fix item_presets unique index (uuid + case-insensitive name)

Goal: Replace the invalid index with a proper composite unique index on (org_id, lower(name)).

1) SQL migration (idempotent & safe)
-- 1) Drop the bad index if it exists
DROP INDEX IF EXISTS item_presets_org_name_unique;

-- 2) (Optional) detect duplicates that would block the new unique index
WITH dups AS (
  SELECT org_id, LOWER(name) AS lname, COUNT(*) AS cnt
  FROM item_presets
  GROUP BY org_id, LOWER(name)
  HAVING COUNT(*) > 1
)
SELECT *
FROM item_presets ip
JOIN dups d
  ON d.org_id = ip.org_id AND d.lname = LOWER(ip.name)
ORDER BY ip.org_id, LOWER(ip.name), ip.created_at NULLS FIRST;


If the query returns rows, you have duplicates. Keep one row per (org_id, lower(name)) and delete the rest:

-- Example dedupe: keep the newest row per (org_id, lower(name))
WITH ranked AS (
  SELECT
    id,
    org_id,
    name,
    ROW_NUMBER() OVER (PARTITION BY org_id, LOWER(name) ORDER BY created_at DESC NULLS LAST, id DESC) AS rn
  FROM item_presets
)
DELETE FROM item_presets
WHERE id IN (
  SELECT id FROM ranked WHERE rn > 1
);


Now create the correct index:

-- 3) Create the correct composite unique index (uuid + expression)
CREATE UNIQUE INDEX item_presets_org_name_unique
ON item_presets (org_id, LOWER(name));


That’s all—no text_ops anywhere.

2) Drizzle schema update (so future pushes don’t reintroduce the bad DDL)

In your drizzle schema file (where item_presets is defined):

import { pgTable, uuid, text, numeric, timestamp, index, uniqueIndex, sql } from "drizzle-orm/pg-core";

export const itemPresets = pgTable("item_presets", {
  id: uuid("id").defaultRandom().primaryKey(),
  orgId: uuid("org_id").notNull(),        // uuid stays uuid
  name: text("name").notNull(),
  unitAmount: numeric("unit_amount", { precision: 12, scale: 2 }).notNull().default("0"),
  taxRate: numeric("tax_rate", { precision: 5, scale: 2 }).notNull().default("0"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
}, (t) => ({
  // ✅ composite unique on (org_id, lower(name))
  orgNameUnique: uniqueIndex("item_presets_org_name_unique").on(
    t.orgId,
    sql`lower(${t.name})`
  ),
}));


Note: sql\lower(${t.name})`tells Drizzle to build an expression index forlower(name)without messing withorg_id`.

3) If a previous migration keeps re-applying the bad index

Remove/replace that migration, or add a new migration that drops the wrong index and creates the correct one (as above).

Then run your usual migration step (drizzle-kit push / your Replit deploy flow).

Quick sanity checks (after migration)
-- Should be exactly one row:
SELECT * FROM pg_indexes WHERE indexname = 'item_presets_org_name_unique';

-- Should succeed, case-insensitive within same org:
INSERT INTO item_presets (org_id, name, unit_amount, tax_rate)
VALUES ('<some-uuid>', 'Labour', 125.00, 10.00);

-- This should fail with unique violation for the same org (case-insensitive):
INSERT INTO item_presets (org_id, name, unit_amount, tax_rate)
VALUES ('<some-uuid>', 'labour', 125.00, 10.00);